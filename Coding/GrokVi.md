# 透悉Vi Grok Vi

## 引

​	现在的代码编辑器层出不穷，好比Sublime，Atom，VScode，WebStorm等等，大多都支持插件扩展。各有各的特色。但是我在这些现代编辑器上装上Vim插件后，体验就良莠不齐了。最终在今天，我在服务器上使用vim对代码进行微调时，让我产生了回归终端vim的心。

​	vim历经了这么多年的发现，插件层出不穷。各家各人都会自己习惯的配置。在我装完那些vim眼花缭乱的自定义配置后，我根本不知道有哪些功能是我需要的，哪些原生的功能被替代了。

​	有趣的是，当我下决心自定义vim配置时，我搜索了大量文章，却意外获得了许多vi编辑器的经验，下面一起来感受一下vi/vim时代的强大。

##  vi 的禅

​	多数人在初次使用vim的时候，都会不习惯于`dd/yy`+ `p` 之于vim，毕竟我们习惯了`ctrl+c` 和`ctrl+v`。 

​	其实vi 的哲理在于当你在进行编辑操作的时候，就好比陈述，好似人对电脑口述命令。



### 动词 Verb

​		`y` 就是一个动词，告诉vi我需要coPy。`yy` 则是`yz` 的别名，为了方便操作，表示我要复制这一行。类似的，`d` 也是一个动词，告诉vi我要Delete，`dd` 则是说我要删除这一行。当然这时候，这一行的数据其实存放到匿名寄存器中，可以看到这个副作用，正好完成了Cut的动作。



### 主语 Subject

​	提到了动词，动词产生一个动作，必定会有主语（实施者）。

​	举例来说，`yW` 这句话就表示从当前的位置直到W(下一个整词)进行复制操作。

#### 寄存器 Register

​	在vi中的大多数的操作都会被存放在匿名寄存器中。同时，vi也提供了26个用字母命名的寄存器。注意这些寄存器的名字均为英文字母的小写。

​	使用`m` 指令来标记寄存器，`ma` 表示当前位置将被标记并存放在a寄存器中，`y'a` 则表示从当前位置到a寄存器的标记位置进行复制操作。

​	单引号`'` +字母，表示到寄存器标记位置所在的行

​	反引号`+字母，表示到寄存器的精确标记位置

​	现在，我们有了主语，有了动词，我们不需要进行宏录制，也能进行许多以前不能进行的操作了。

#### 段落 Paragraph

​	现在，我们来了解段落的标记位置。`{` 和`}` ，使用后会分别移动到段落前/后的位置。配置前述的动词来构成新的对话。

​	`{`  `d}` 只是用的3个按键就对当前的段落进行了剪切操作。如果你正好在段首，段尾，`d{` `d}` 就更方便了。

####  正则表达式

​	你是否想过，正则表达式也可以作句子的主语。

​	`d/foo` **从 当前行 到 下一个含有字符串foo的行** 进行 **剪切**

​	`y?bar` **从 当前位置 到 下一个含有字符串bar的上一行** 进行 **复制**



### 宾语 Object

​	有了主语，动词，就一定会有宾语 Object。

#### 命名寄存器

​	26个字母命名的寄存器中的内容，通过加前缀`“` 来调用，就可以充当宾语。

​	`"add` 当前行 剪切到 a寄存器

​	`"by/foo` 从 当前位置 到 下一个含有字符串foo的行 复制到 b寄存器

​	`"ap` 在下一行 打印 a寄存器的内容

​	`"bP` 在上一行 打印 b寄存器的内容



### 形容词与副词 Adjective and Adverbs

​	`3J` 对下面3行的内容 进行连接

​	`d5}` 	从当前行 到 下面5个段落段尾 进行删除



___

## 进阶技巧

## `:` 行编辑器

`:% s/foo/bar/g`	在所有行，出现的所有foo 替换成 bar

vi出生的年代，大多数终端设备还是teletype(TTY)设备，经常要同过一个简陋的交互界面（通常连接速度在110波特，粗略地说就是 11字符/秒，比一个快速的打印机还慢）对打印出的文本副本进行操作。

所以，`:` 是行编辑器的代名词，通常涉及到的都是多行操作，这样就会有一个操作范围。

例如，`:127,215 s/foo/bar` 界定了在127到215行，对foo替换成bar的操作。

### 缩写

行操作时，`.` 表示当前行，`$` 表示最后一行，`+` 和`-` 表示相对当前行向后/向前偏移行

​	`:.,$j` 当前行到最后一行，进行连接

​	`:%` 和`:1,$` 都表示所有行

### g 和 v

g - globally

v - conVerse paper

`:… g` 代表了后续操作是全局匹配随后的正则（在行界定的范围内）

`:… v` 表示了后续操作时全局 **不** 匹配随后的正则 （在行界定的范围内）

举例来说

`:.,+21g/foo/d` 在当前行到随后的21行内，出现的所有含有 foo 的行都删除

`:.,$v/bar/d` 在当前行到最后一行内，出现的所有 **不** 含有 bar 的行都删除



记住，`:… v/re/…` 是一个很常用的指令

#### grep

grep指令正是受到了 g 的启发，效果和 `:g/re/p`一样

grep -v 就跟 `:v/re/p` 结果相同



## m指令

​	m在vi中可以用来移动多行，同时配合`j` 移动后再连接内容。

下面举例来说：

`:% g/foo/m$` 将全文中所有含有 foo 的行都移动到了文档末尾

就好比运行了`1G!GGmap!Ggrep foo<ENTER>1G:1, 'a g/foo'/d` 

复制文档内容到结尾，通过grep指令过滤结尾，然后从头删除所有内容



## j指令 连接空行

​	通常，我们连接行之前，都需要通过正则来得到要连接的内容，之后使用`j` 连接到上一行

​	`:%g/^  /-1j` 对所有的空行（这边排除了块注释可能用到的 * 行）



## s指令 替换

​	我们知道`:% s/foo/bar/g` 可以对所有行中出现的所有foo替换成bar。他也可以和g/v指令配合，甚至和寄存器配合，划定范围。

### 配合g/v

`:% g/foo/s/bar/zzz/g` 所有含有foo的行中，对所有bar替换成zzz

这种操作方便非常便捷，完整。

​	同样地，如果使用类似`:%s/\(.* foo.*\ )bar\ ( . * \ )/\1zzz\2/g`不仅冗长，而且只能替换foo出现后的bar，并不能得到我们想要的结果  

### 配合寄存器

`:'a,'b g/foo/j` 在a，b寄存器中间的行，都会连接到其下一行



## :r指令

:r 他的功能是将其他文件的内容读取到当前位置。

`:r foo` 将文件 foo 中的内容插入到当前行



## :! bang指令

！表示运行，他会运行后续的操作，然后将结果输出到当前内容。

`1G!Gsort` 对全文进行排序整理

等同于`:1,$!sort` 

### 配合 fmt 或者 fold 工具

`{!}fmt` 对当前段落重新格式化 reformat



### 配合r指令 :r!

`:r!` 和`!` 表示任何外部的工具或者过滤器都能被当成编辑器的插件来使用。例如，从数据库中拉取数据，或者使用 wget 或 lynx 命令从网站提取数据，又或者使用 ssh 指令从远程服务器获取数据



## :so (:source)

​	`:so` 是 `:source` 的缩写形式，他用来读取包含一系列操作的外部文件。

用法是，`:source ~/.vimrc` 就可以从 .vimrc 中读取自定义的配置。



如果，现在我有一个宏指令文件，作用是统计单词数，在文件头部插入一个注释，显示文件的单词数，就可以使用`so` 来应用到其他文件。

`vim +'so mymacro.ex' ./mytarget`

`+`在vim中 通常用来让vim从给定的行数开始编辑，这里借用来使用外部宏。



`vi +'/foo/d|wq!' ~/.ssh/known_hosts` 从SSH的know_hosts中删除含有字符串foo的行



同过外加宏指令，可以配置Perl， AWK， sed来实现不同的操作。



## @指令

`@` 是一个较少人使用的指令，他的功能是运行给定的命名寄存器中的指令。

比如说，我要用`:r!locate …` 来查找系统中的文件，然后获取文件名。

现在可以这么做：

- `0i:r` 移动到行首，插入`:r` 

- `"cdd` 删除当前行，并存放到c寄存器

- `@c` 运行c寄存器中的指令

  ​

## q指令 

通过q来录制宏命令：

- 第一次按下`q` 表示将要录制宏
- 接着按下任意字母，例如`c` ，表示宏指令存放在某个字母寄存器中(以c寄存器为例)
- 底部出现recording，表示正在录制，进行所需的宏操作
- 完成后，再次按`q` 退出

配合上述的@指令

`@c` 就可以多次运行存放在c寄存器中的宏指令



# 参考链接 Resource

- [what is your most productive shortcut within vim](http://stackoverflow.com/questions/1218390/what-is-your-most-productive-shortcut-with-vim)



## 结语

​	如果想要用好vim，理解作者的设计思路是很重要的。希望通过这篇文章，更深刻的理解作者的哲思。